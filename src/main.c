#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    pal,            sensorPotentiometer)
#pragma config(Sensor, in2,    par,            sensorPotentiometer)
#pragma config(Sensor, in3,    ps,             sensorPotentiometer)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           fl,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           fr,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           bl,            tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           br,            tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port6,           al,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           ar,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           s,             tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

#define PA_LOW_POLE 650
#define PA_HIGH_POLE 1450
#define PA_SAFE 2000
#define PS_PARALLEL 1000
#define PS_SAFE 2100

#define PA_VALUE ((SensorValue(pal) + SensorValue(par)) / 2)

short pa_target;
byte arm;
short ps_target;
byte sprocket;
short pa_prev;

void pre_auton() {
	resetMotorEncoder(fl);
	resetMotorEncoder(fr);
	resetMotorEncoder(bl);
	resetMotorEncoder(br);
}

task autonomous() {
	resetMotorEncoder(bl);
	resetMotorEncoder(br);
	motor[fl] = motor[bl] = -127;
	while (nMotorEncoder(bl) > -1200);
	motor[fl] = motor[bl] = 0;
	motor[fr] = motor[br] = -127;
	while (nMotorEncoder(br) > -1200);
	motor[fr] = motor[br] = 0;
	resetMotorEncoder(bl);
	resetMotorEncoder(br);
	motor[fl] = motor[fr] = motor[bl] = motor[br] = -127;
	while ((nMotorEncoder(bl) + nMotorEncoder(br)) / 2 > -2000);
	motor[fl] = motor[fr] = motor[bl] = motor[br] = 0;
}

float battery;

task usercontrol() {
	while (1) {
		battery = nImmediateBatteryLevel * 0.001;
		if (sgn(PA_VALUE - pa_target) == sgn(arm)) {
			pa_target = 0;
			arm = 0;
		}
		if (sgn(SensorValue(ps) - ps_target) == sgn(sprocket)) {
			ps_target = 0;
			sprocket = 0;
		}
		motor[fl] = motor[bl] = vexRT[Ch3];
		motor[fr] = motor[br] = vexRT[Ch2];
		if (vexRT[Btn6U]) {
			if (PA_VALUE < PA_SAFE) {
				motor[al] = motor[ar] = 127;
				pa_target = 0;
				arm = 0;
			}
		} else if (vexRT[Btn6D]) {
			motor[al] = motor[ar] = -127;
			pa_target = 0;
			arm = 0;
		} else if (pa_target) {
			motor[al] = motor[ar] = arm;
		} else {
			motor[al] = motor[ar] = 0;
		}
		if (vexRT[Btn5U]) {
			motor[s] = 127;
			ps_target = 0;
			sprocket = 0;
		} else if (vexRT[Btn5D]) {
			motor[s] = -127;
			ps_target = 0;
			sprocket = 0;
		} else if (ps_target) {
			motor[s] = sprocket;
		} else {
			motor[s] = 0;
		}
		if (vexRT[Btn8R] && !pa_target) {
			pa_target = PA_LOW_POLE;
			arm = PA_VALUE < pa_target ? 127 : -127;
		}
		if (vexRT[Btn8U] && !pa_target) {
			pa_target = PA_HIGH_POLE;
			arm = PA_VALUE < pa_target ? 127 : -127;
		}
		if (vexRT[Btn7D] && !ps_target
			|| pa_prev > 1000 && PA_VALUE <= 1000 && SensorValue(ps) > PS_SAFE) {
			ps_target = PS_PARALLEL;
			sprocket = SensorValue(ps) < ps_target ? 127 : -127;
		}
		pa_prev = PA_VALUE;
	}
}
